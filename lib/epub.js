// Generated by CoffeeScript 1.7.1
(function() {
  'use strict';
  var AdmZip, EPub, HTTP, Q, URL, exports, parseXML, _;

  URL = require('url');

  _ = require('lodash');

  AdmZip = require('adm-zip');

  HTTP = require('q-io/http');

  Q = require('q');

  parseXML = require('./xml-parser');

  EPub = (function() {
    EPub.factory = function(resource) {
      var epub;
      epub = new EPub(resource);
      return epub.init();
    };

    function EPub(resource) {
      this.resource = resource;
      this.isRemote = (URL.parse(this.resource)).host != null;
      this.isInitialized = false;
      return this;
    }

    EPub.prototype.init = function() {
      var deferred;
      deferred = Q.defer();
      if ((this.zip != null) && (this.rendition != null)) {
        deferred.resolve(this);
      } else {
        Q["try"]((function(_this) {
          return function() {
            deferred.notify({
              message: "Initializing " + _this.resource + "..."
            });
            if (_this.isRemote) {
              deferred.notify("Requesting " + _this.resource + " remotely...");
              return deferred.resolve(HTTP.read(_this.resource).then(_this.parseZip));
            } else {
              return deferred.resolve(_this.parseZip(_this.resource));
            }
          };
        })(this))["catch"](deferred.reject);
      }
      return deferred.promise;
    };

    EPub.prototype.parseZip = function(resource, encoding) {
      var deferred;
      if (resource == null) {
        resource = this.resource;
      }
      if (encoding == null) {
        encoding = 'utf8';
      }
      deferred = Q.defer();
      Q["try"]((function(_this) {
        return function() {
          deferred.notify({
            message: "Parsing " + resource + "..."
          });
          _this.zip = new AdmZip(resource);
          return Q.allSettled([_this.getEntryAsText('mimetype', encoding), _this.getEntryAsText('META-INF/container.xml', encoding)]).spread(function(mimetype, container) {
            var err, _ref;
            if (mimetype.value !== 'application/epub+zip') {
              err = new TypeError("" + resource + " not a valid epub (mimetype).");
              deferred.reject(err);
            }
            if (!((_ref = container.value) != null ? _ref.length : void 0)) {
              err = new Error("No epub container file found for " + resource + ".");
              deferred.reject(err);
            }
            deferred.notify({
              message: "Getting rootfile(s) for " + resource + "..."
            });
            return parseXML(container.value);
          }).then(function(xml) {
            _this.rootfiles = [];
            _.forEach(xml.rootfiles, function(rootfile) {
              return _this.rootfiles.push(rootfile['$']['FULL-PATH']);
            });
            return _this.render();
          }).then(function() {
            return _this;
          });
        };
      })(this))["catch"](deferred.reject).done(deferred.resolve);
      return deferred.promise;
    };

    EPub.prototype.render = function(index) {
      var count, deferred, err, _ref;
      if (index == null) {
        index = 0;
      }
      deferred = Q.defer();
      if (this.rendition && (((_ref = this.rootfiles) != null ? _ref[index] : void 0) != null)) {
        deferred.resolve(this.rendition);
      } else if (this.rootfiles[index] != null) {
        Q["try"]((function(_this) {
          return function() {
            var message;
            message = "Rendering " + _this.resource + " using " + _this.rootfiles[index] + "...";
            deferred.notify({
              message: message
            });
            return _this.getEntryAsText(_this.rootfiles[index]).then(parseXML)["catch"](deferred.reject).done(function(xml) {
              var tocID, _ref1, _ref2, _ref3;
              _this.rendition = xml;
              _this.manifest = _.pluck((_ref1 = xml.manifest) != null ? _ref1.item : void 0, '$');
              _this.spine = _.pluck((_ref2 = xml.spine) != null ? _ref2.itemref : void 0, '$');
              tocID = (_ref3 = xml.spine) != null ? _ref3['$']['TOC'] : void 0;
              _this.tocFile = (_.find(_this.manifest, {
                ID: tocID
              }))['HREF'];
              return deferred.resolve(_this.rendition);
            });
          };
        })(this));
      } else {
        count = this.rootfiles.length;
        err = new RangeError("" + this.resource + " only has " + count + " root file(s).");
        deferred.reject(err);
      }
      return deferred.promise;
    };

    EPub.prototype.getFlow = function() {
      if (!((this.spine != null) && (this.manifest != null))) {
        throw new ReferenceError("" + this.resource + " must be initialized first.");
      }
      if (this.flow != null) {
        return this.flow;
      } else {
        this.flow = [];
        _.forEach(this.spine, (function(_this) {
          return function(item) {
            var entry, page;
            page = _.find(_this.manifest, {
              ID: item['IDREF']
            });
            entry = {
              id: item['IDREF'],
              href: page['HREF'],
              mimetype: page['MEDIA-TYPE']
            };
            return _this.flow.push(entry);
          };
        })(this));
        return this.flow;
      }
    };

    EPub.prototype.getTOC = function() {
      var deferred, tocMapper;
      deferred = Q.defer();
      if (this.toc != null) {
        deferred.resolve(this.toc);
      } else {
        tocMapper = function(navpoints) {
          return _.map(navpoints, function(item) {
            var result, _ref;
            result = {
              id: item['$']['ID'],
              order: item['$']['PLAYORDER'],
              label: item.navlabel.text,
              href: item.content['$']['SRC']
            };
            if ((_ref = item.navpoint) != null ? _ref.length : void 0) {
              result.children = tocMapper(item.navpoint);
            }
            return result;
          });
        };
        this.getEntryAsText(this.tocFile).then(parseXML)["catch"](deferred.reject).done((function(_this) {
          return function(xml) {
            var err, _ref;
            if (!(xml != null ? (_ref = xml.navmap) != null ? _ref.navpoint : void 0 : void 0)) {

              /* @TODO: test invalid tocFile for getTOC() */
              err = new TypeError("" + _this.tocFile + " is not a valid toc file.");
              return deferred.reject(err);
            } else {
              _this.toc = tocMapper(xml.navmap.navpoint);
              return deferred.resolve(_this.toc);
            }
          };
        })(this));
      }
      return deferred.promise;
    };

    EPub.prototype.getEntryAsText = function(href, encoding) {
      var deferred;
      if (encoding == null) {
        encoding = 'utf8';
      }
      deferred = Q.defer();
      this.findZipEntry(href).then((function(_this) {
        return function(entry) {
          return _this.zip.readAsTextAsync(entry, function(content) {
            if (!(content != null ? content.length : void 0)) {

              /* @TODO: test no content error for getEntryAsText() */
              return deferred.reject(new Error("" + href + " has no content."));
            } else {
              return deferred.resolve(content);
            }
          }, encoding);
        };
      })(this))["catch"](deferred.reject);
      return deferred.promise;
    };

    EPub.prototype.getEntryAsBuffer = function(href) {
      var deferred;
      deferred = Q.defer();
      this.findZipEntry(href).then((function(_this) {
        return function(entry) {
          return _this.zip.readFileAsync(entry, function(content) {
            if (!(content != null ? content.length : void 0)) {

              /* @TODO: test no content error for getEntryAsBuffer() */
              return deferred.reject(new Error("" + href + " has no content."));
            } else {
              return deferred.resolve(content);
            }
          });
        };
      })(this))["catch"](deferred.reject);
      return deferred.promise;
    };

    EPub.prototype.getEntry = function(href) {
      var deferred;
      deferred = Q.defer();
      this.getEntryAsBuffer(href).then((function(_this) {
        return function(data) {
          var result;
          if (data == null) {

            /* @TODO: test no data error for getEntry() */
            return deferred.reject(new Error("" + href + " has no data."));
          } else {
            result = {
              data: data,
              mimetype: (_.find(_this.manifest, {
                HREF: href
              }))['MEDIA-TYPE']
            };
            return deferred.resolve(result);
          }
        };
      })(this))["catch"](deferred.reject);
      return deferred.promise;
    };

    EPub.prototype.findZipEntry = function(name) {
      var deferred, entryName, fileEntry, item;
      deferred = Q.defer();
      if (this.zip == null) {
        deferred.reject(new Error("" + this.resource + " must be initialized first."));
      } else {
        item = _.find(this.manifest, {
          ID: name
        });
        entryName = (item != null ? item['HREF'] : void 0) || name;
        fileEntry = this.zip.getEntry(entryName);
        if (fileEntry == null) {
          if (this.entries == null) {
            this.entries = this.zip.getEntries();
          }
          fileEntry = _.find(this.entries, function(entry) {
            return entry.entryName.toLowerCase() === name.toLowerCase();
          });
        }
        if (fileEntry == null) {
          deferred.reject(new Error("" + name + " not an entry in " + this.resource + "."));
        } else {
          deferred.resolve(fileEntry);
        }
      }
      return deferred.promise;
    };

    return EPub;

  })();

  exports = module.exports = EPub;

}).call(this);
